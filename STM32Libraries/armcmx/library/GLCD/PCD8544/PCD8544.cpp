/*
 7-17-2011
 Spark Fun Electronics 2011
 Nathan Seidle
 
 This code is public domain but you buy me a beer if you use this and we meet someday (Beerware license).
 
 This code writes a series of images and text to the Nokia 5110 84x48 graphic LCD:
 http://www.sparkfun.com/products/10168
 
 Do not drive the backlight with 5V. It will smoke. However, the backlight on the LCD seems to be 
 happy with direct drive from the 3.3V regulator.

 Although the PCD8544 controller datasheet recommends 3.3V, the graphic Nokia 5110 LCD can run at 3.3V or 5V. 
 No resistors needed on the signal lines.
 
 You will need 5 signal lines to connect to the LCD, 3.3 or 5V for power, 3.3V for LED backlight, and 1 for ground.
 */

/*
#include "armcore.h"
#include "gpio.h"
#include "delay.h"
#include "SPI.h"
*/
#include <ctype.h>

#include "PCD8544.h"
#include "fonts.h"
/*
void setup(void) {
  LCDInit(); //Init the LCD
}

void loop(void) {
  LCDClear();
  LCDBitmap(SFEFlame);
  delay(1000);

  LCDClear();
  LCDBitmap(SFEFlameBubble);
  delay(1000);

  LCDClear();
  LCDBitmap(awesome);
  delay(1000);

  LCDClear();
  LCDString("Hello World!");
  delay(1000);
}
*/
void PCD8544::gotoXY(int x, int y) {
	select();
  write(0, 0x80 | x);  // Column.
  write(0, 0x40 | y);  // Row.  ?
	deselect();
	textcursor = x + y* 84 ;
}

void PCD8544::cursor(int col) {
	textcursor = col;
}

//This takes a large array of bits and sends them to the LCD
void PCD8544::drawBitmap(const byte my_array[], const byte width, const byte height){
	int ix;
	select();
	ix = 0;
  for (int r = 0 ; r < height/8 + ( height%8 ? 1 : 0 ); r++)
		for (int c = 0 ; c < width; c++)
			write(LCD_DATA, my_array[ix++]);
	deselect();
}

//This function takes in a character, looks it up in the font table/array
//And writes it to the screen
//Each character is 8 bits tall and 5 bits wide. We pad one blank column of
//pixels on each side of the character for readability.
void PCD8544::drawCharacter(const char ch) {
	if ( font[2] == 'F' )
		drawFixedFont(font, ch);
	else
		drawProportionalFont(font, ch);
}

void PCD8544::drawFixedFont(const byte font[], char character) {
	uint16 width = font[0];
	uint16 percolumn = (font[1]&0x7f)/8 + ((font[1]&0x7f)%8 ? 1 : 0);
//	boolean transpo = (font[1] & 0x80 ? 1 : 0);
	uint16 idx = 3 + (character - ' ') * width * percolumn;
//	byte t;
	
	if ( (textcursor % 84) + width+2 >= 84 )
		textcursor = (textcursor/84 + 1)*84;
	if ( character == 0x20 && textcursor%84 == 0 )
		return;
	select();
	for(int bytepos = 0; bytepos < percolumn; bytepos++) {
		write(0, 0x80 | textcursor % 84);  // Column.
		write(0, 0x40 | percolumn*(textcursor/84) + bytepos ); //0+bytepos+(textcursor/84)*percolbytes);  // Row.  ?
		write(LCD_DATA, 0x00); //Blank vertical line padding
		for (int i = 0 ; i < width ; i++) {
			write(LCD_DATA, font[idx + bytepos + i*percolumn]);
		}
		write(LCD_DATA, 0x00); //Blank vertical line padding
	}
	deselect();
	//
	textcursor += width + 2;

}

//This function takes in a character, looks it up in the font table/array
//And writes it to the screen
//Each character is 8 bits tall and 5 bits wide. We pad one blank column of
//pixels on each side of the character for readability.
void PCD8544::drawProportionalFont(const byte font[], char character) {
//	byte mxwidth = font[0];
	byte height = font[1];
//	byte proportional = font[2];

	byte percolbytes = height/8 + height%2;
//	byte textrow = textcursor/percolbytes;
	
	uint16 idx = 3;
	byte fontwidth;
	byte ch = 0x20;
	for( ; ch != character; ch++) 
		idx += 1 + font[idx]*percolbytes;
	fontwidth = font[idx];
	idx++;
	
	if ( (textcursor % 84) + fontwidth+2 >= 84 )
		textcursor = (textcursor/84 + 1)*84;
	if ( character == 0x20 && textcursor%84 == 0 )
		return;
	select();
	for(int bytepos = 0; bytepos < percolbytes; bytepos++) {
		write(0, 0x80 | textcursor % 84);  // Column.
		write(0, 0x40 | percolbytes*(textcursor/84) + bytepos ); //0+bytepos+(textcursor/84)*percolbytes);  // Row.  ?
		write(LCD_DATA, 0x00); //Blank vertical line padding
		for (int i = 0 ; i < fontwidth ; i++) {
			write(LCD_DATA, font[idx + bytepos + i*percolbytes]);
		}
		write(LCD_DATA, 0x00); //Blank vertical line padding
	}
	deselect();
	//
	textcursor += fontwidth + 2;
}

//Given a string of characters, one by one is passed to the LCD
void PCD8544::drawString(const char *characters) {
  while (*characters)
    drawCharacter(*characters++);
}

//Clears the LCD by writing zeros to the entire screen
void PCD8544::clear(void) {
	select();
  for (int index = 0 ; index < (LCD_X * LCD_Y / 8) ; index++)
    write(LCD_DATA, 0x00);
	deselect();
  gotoXY(0, 0); //After we clear the display, return to the home position
	textcursor = 0;
}

//This sends the magical commands to the PCD8544
void PCD8544::init(void) {
	
  //Configure control pins
  //pinMode(pin_SCE, OUTPUT);
  pinMode(pin_RESET, OUTPUT);
  pinMode(pin_DC, OUTPUT);
  //pinMode(pin_SDIN, OUTPUT);
  //pinMode(pin_SCLK, OUTPUT);
	digitalWrite(pin_RESET, HIGH);
	delay(5);
	
  //Reset the LCD to a known state
  digitalWrite(pin_RESET, LOW);
  digitalWrite(pin_RESET, HIGH);

	select();
  write(LCD_COMMAND, 0x21); //Tell LCD that extended commands follow
  write(LCD_COMMAND, 0xB1); //Set LCD Vop (Contrast): Try 0xB1(good @ 3.3V) or 0xBF if your display is too dark
  write(LCD_COMMAND, 0x04); //Set Temp coefficent
  write(LCD_COMMAND, 0x14); //LCD bias mode 1:48: Try 0x13 or 0x14

  write(LCD_COMMAND, 0x20); //We must send 0x20 before modifying the display control mode
  write(LCD_COMMAND, 0x0C); //Set display control, normal mode. 0x0D for inverse
	deselect();
}


void PCD8544::setContrast(const uint8 val) {
	
	select();
  write(LCD_COMMAND, 0x21); //Tell LCD that extended commands follow
  write(LCD_COMMAND, val); //Set LCD Vop (Contrast): Try 0xB1(good @ 3.3V) or 0xBF if your display is too dark
  write(LCD_COMMAND, 0x04); //Set Temp coefficent
  write(LCD_COMMAND, 0x14); //LCD bias mode 1:48: Try 0x13 or 0x14

  write(LCD_COMMAND, 0x20); //We must send 0x20 before modifying the display control mode
  write(LCD_COMMAND, 0x0C); //Set display control, normal mode. 0x0D for inverse
	deselect();
}


//There are two memory banks in the LCD, data/RAM and commands. This 
//function sets the DC pin high or low depending, and then sends
//the data byte
void PCD8544::write(byte data_or_command, byte data) {
	//spi_setMode(SPIBx, 64, SPI_CPOL_High, SPI_CPHA_2Edge, SPI_MSBFIRST); // mode 3, msb first
	
  digitalWrite(pin_DC, data_or_command); //Tell the LCD that we are writing either to data or a command
  //Send the data
  //digitalWrite(pin_SCE, LOW);
	spi_transfer(&spibus,data);
//  shiftOut(PIN_SDIN, PIN_SCLK, SPI_MSBFIRST, data);
  //digitalWrite(pin_SCE, HIGH);
}


//This is the SFE flame in bit form
const byte PCD8544::SFEFlame[] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xE0, 0xF0, 0xF8, 0xFC, 0xFC, 0xFE, 0xFE, 0xFE, 0xFE, 0x1E, 0x0E, 0x02, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFE, 0xFC, 0xF8, 0xF8, 0xF0, 0xF8, 0xFE, 0xFE, 0xFC, 0xF8, 0xE0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0xF8, 0xFC, 0xFE, 0xFE, 0xFF, 0xFF, 0xF3, 0xE0, 0xE0, 0xC0, 0xC0, 0xC0, 0xE0, 0xE0,
  0xF1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F,
  0x3F, 0x1F, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0x7F, 0x3F, 0x1F, 0x0F, 0x0F, 0x0F, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x03, 0x03,
  0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x1F,
  0x0F, 0x07, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};

//Another SparkFun logo
/*
const byte Nokia5110::SFEFlameBubble [] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
  0xC0, 0xC0, 0xE0, 0xE0, 0xF0, 0xF8, 0xF8, 0xFC, 0xFC, 0xFC, 0xFC, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE,
  0xFE, 0xFE, 0xFE, 0xFE, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xF8, 0xF0, 0xE0, 0xE0, 0xC0, 0xC0, 0x80,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xE0,
  0xF8, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x3F, 0x3F,
  0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x3F, 0x3F, 0x3F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xF8, 0xE0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xC0, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x0F, 0x3F, 0x7F, 0x7F, 0x3F, 0x1E,
  0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x03, 0x0F, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x01, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xF0, 0xE0,
  0xE0, 0xC0, 0xC0, 0xE0, 0xE0, 0xE0, 0xF0, 0xF8, 0x7C, 0x7C, 0x7E, 0x7C, 0x38, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x1F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xF8, 0xE0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x0F, 0x3F, 0x7F, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0xF0, 0xF0,
  0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0,
  0xE1, 0xE3, 0xE3, 0xE7, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xE0,
  0xC0, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x07, 0x07, 0x0F, 0x1F, 0x1F, 0x1F, 0x3F, 0x3F, 0x3F, 0x3F,
  0x3F, 0x3F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
  0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,
  0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7E, 0x7C, 0x78, 0x70, 0x60, 0x40, 0x40, 0x00,
  0x00,
};
*/

//This table contains the hex values that represent pixels
//for a font that is 5 pixels wide and 8 pixels high
const byte PCD8544::Fixed_8w5[] = {
	 0x05, 0x08, 'F', // width, hright, proprtional
   0x00, 0x00, 0x00, 0x00, 0x00,  // 20  
   0x00, 0x00, 0x5f, 0x00, 0x00,  // 21 !
   0x00, 0x07, 0x00, 0x07, 0x00,  // 22 "
   0x14, 0x7f, 0x14, 0x7f, 0x14,  // 23 #
   0x24, 0x2a, 0x7f, 0x2a, 0x12,  // 24 $
   0x23, 0x13, 0x08, 0x64, 0x62,  // 25 %
   0x36, 0x49, 0x55, 0x22, 0x50,  // 26 &
   0x00, 0x05, 0x03, 0x00, 0x00,  // 27 '
   0x00, 0x1c, 0x22, 0x41, 0x00,  // 28 (
   0x00, 0x41, 0x22, 0x1c, 0x00,  // 29 )
   0x14, 0x08, 0x3e, 0x08, 0x14,  // 2a *
   0x08, 0x08, 0x3e, 0x08, 0x08,  // 2b +
   0x00, 0x50, 0x30, 0x00, 0x00,  // 2c ,
   0x08, 0x08, 0x08, 0x08, 0x08,  // 2d -
   0x00, 0x60, 0x60, 0x00, 0x00,  // 2e .
   0x20, 0x10, 0x08, 0x04, 0x02,  // 2f /
   0x3e, 0x51, 0x49, 0x45, 0x3e,  // 30 0
   0x00, 0x42, 0x7f, 0x40, 0x00,  // 31 1
   0x42, 0x61, 0x51, 0x49, 0x46,  // 32 2
   0x21, 0x41, 0x45, 0x4b, 0x31,  // 33 3
   0x18, 0x14, 0x12, 0x7f, 0x10,  // 34 4
   0x27, 0x45, 0x45, 0x45, 0x39,  // 35 5
   0x3c, 0x4a, 0x49, 0x49, 0x30,  // 36 6
   0x01, 0x71, 0x09, 0x05, 0x03,  // 37 7
   0x36, 0x49, 0x49, 0x49, 0x36,  // 38 8
   0x06, 0x49, 0x49, 0x29, 0x1e,  // 39 9
   0x00, 0x36, 0x36, 0x00, 0x00,  // 3a :
   0x00, 0x56, 0x36, 0x00, 0x00,  // 3b ;
   0x08, 0x14, 0x22, 0x41, 0x00,  // 3c <
   0x14, 0x14, 0x14, 0x14, 0x14,  // 3d =
   0x00, 0x41, 0x22, 0x14, 0x08,  // 3e >
   0x02, 0x01, 0x51, 0x09, 0x06,  // 3f ?
   0x32, 0x49, 0x79, 0x41, 0x3e,  // 40 @
   0x7e, 0x11, 0x11, 0x11, 0x7e,  // 41 A
   0x7f, 0x49, 0x49, 0x49, 0x36,  // 42 B
   0x3e, 0x41, 0x41, 0x41, 0x22,  // 43 C
   0x7f, 0x41, 0x41, 0x22, 0x1c,  // 44 D
   0x7f, 0x49, 0x49, 0x49, 0x41,  // 45 E
   0x7f, 0x09, 0x09, 0x09, 0x01,  // 46 F
   0x3e, 0x41, 0x49, 0x49, 0x7a,  // 47 G
   0x7f, 0x08, 0x08, 0x08, 0x7f,  // 48 H
   0x00, 0x41, 0x7f, 0x41, 0x00,  // 49 I
   0x20, 0x40, 0x41, 0x3f, 0x01,  // 4a J
   0x7f, 0x08, 0x14, 0x22, 0x41,  // 4b K
   0x7f, 0x40, 0x40, 0x40, 0x40,  // 4c L
   0x7f, 0x02, 0x0c, 0x02, 0x7f,  // 4d M
   0x7f, 0x04, 0x08, 0x10, 0x7f,  // 4e N
   0x3e, 0x41, 0x41, 0x41, 0x3e,  // 4f O
   0x7f, 0x09, 0x09, 0x09, 0x06,  // 50 P
   0x3e, 0x41, 0x51, 0x21, 0x5e,  // 51 Q
   0x7f, 0x09, 0x19, 0x29, 0x46,  // 52 R
   0x46, 0x49, 0x49, 0x49, 0x31,  // 53 S
   0x01, 0x01, 0x7f, 0x01, 0x01,  // 54 T
   0x3f, 0x40, 0x40, 0x40, 0x3f,  // 55 U
   0x1f, 0x20, 0x40, 0x20, 0x1f,  // 56 V
   0x3f, 0x40, 0x38, 0x40, 0x3f,  // 57 W
   0x63, 0x14, 0x08, 0x14, 0x63,  // 58 X
   0x07, 0x08, 0x70, 0x08, 0x07,  // 59 Y
   0x61, 0x51, 0x49, 0x45, 0x43,  // 5a Z
   0x00, 0x7f, 0x41, 0x41, 0x00,  // 5b [
   0x02, 0x04, 0x08, 0x10, 0x20,  // 5c '\\'
   0x00, 0x41, 0x41, 0x7f, 0x00,  // 5d ]
   0x04, 0x02, 0x01, 0x02, 0x04,  // 5e ^
   0x40, 0x40, 0x40, 0x40, 0x40,  // 5f _
   0x00, 0x01, 0x02, 0x04, 0x00,  // 60 `
   0x20, 0x54, 0x54, 0x54, 0x78,  // 61 a
   0x7f, 0x48, 0x44, 0x44, 0x38,  // 62 b
   0x38, 0x44, 0x44, 0x44, 0x20,  // 63 c
   0x38, 0x44, 0x44, 0x48, 0x7f,  // 64 d
   0x38, 0x54, 0x54, 0x54, 0x18,  // 65 e
   0x08, 0x7e, 0x09, 0x01, 0x02,  // 66 f
   0x0c, 0x52, 0x52, 0x52, 0x3e,  // 67 g
   0x7f, 0x08, 0x04, 0x04, 0x78,  // 68 h
   0x00, 0x44, 0x7d, 0x40, 0x00,  // 69 i
   0x20, 0x40, 0x44, 0x3d, 0x00,  // 6a j 
   0x7f, 0x10, 0x28, 0x44, 0x00,  // 6b k
   0x00, 0x41, 0x7f, 0x40, 0x00,  // 6c l
   0x7c, 0x04, 0x18, 0x04, 0x78,  // 6d m
   0x7c, 0x08, 0x04, 0x04, 0x78,  // 6e n
   0x38, 0x44, 0x44, 0x44, 0x38,  // 6f o
   0x7c, 0x14, 0x14, 0x14, 0x08,  // 70 p
   0x08, 0x14, 0x14, 0x18, 0x7c,  // 71 q
   0x7c, 0x08, 0x04, 0x04, 0x08,  // 72 r
   0x48, 0x54, 0x54, 0x54, 0x20,  // 73 s
   0x04, 0x3f, 0x44, 0x40, 0x20,  // 74 t
   0x3c, 0x40, 0x40, 0x20, 0x7c,  // 75 u
   0x1c, 0x20, 0x40, 0x20, 0x1c,  // 76 v
   0x3c, 0x40, 0x30, 0x40, 0x3c,  // 77 w
   0x44, 0x28, 0x10, 0x28, 0x44,  // 78 x
   0x0c, 0x50, 0x50, 0x50, 0x3c,  // 79 y
   0x44, 0x64, 0x54, 0x4c, 0x44,  // 7a z
   0x00, 0x08, 0x36, 0x41, 0x00,  // 7b {
   0x00, 0x00, 0x7f, 0x00, 0x00,  // 7c |
   0x00, 0x41, 0x36, 0x08, 0x00,  // 7d }
   0x10, 0x08, 0x08, 0x10, 0x08,  // 7e ~
   0x78, 0x46, 0x41, 0x46, 0x78,  // 7f DEL
};

